"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

onmessage = function onmessage(e) {
  var properties = e.data[0];
  var cicles = makeCircles(properties.imageData, properties.circleColours, properties.rmin, properties.rmax, properties.n, properties.LX, properties.LY);
  console.log(cicles[0]);
  postMessage(cicles);
};

function makeCircles(imageData, circleColours, rmin, rmax, n, LX, LY) {
  var circles = [];
  var radii = []; // First choose a set of n random radii and sort them. We use
  // Math.random()*Math.random() to favour small circles.

  for (var i = 0; i < n; i++) {
    var radius = rmin + (rmax - rmin) * (Math.random() * Math.random());
    radii.push(radius);
  }

  radii.sort().reverse(); // Do our best to place the circles, larger ones first.

  for (var _i = 0; _i < n; _i++) {
    placeCircle(circles, radii[_i], imageData, circleColours, LX, LY);
  }

  return circles;
}

;

function placeCircle(circles, radius, imageData, circleColours, LX, LY) {
  //The guard number: if we don't place a circle within this number of trials, we give up.
  var guard = 500;

  var _loop = function _loop() {
    // Pick a random position, uniformly on the image.
    var cx = randomIntFromInterval(0, LX - 1);
    var cy = randomIntFromInterval(0, LY - 1);
    var index = (cx + cy * LX) * 4;
    var red = imageData[index + 0];
    var green = imageData[index + 1];
    var blue = imageData[index + 2];
    var average = (red + green + blue) / 3;

    if (average < 255 / 2 && !circles.some(function (existingCircle) {
      return overlapWith(cx, cy, radius, existingCircle.cx, existingCircle.cy, existingCircle.r);
    })) {
      var circle = {
        'cx': cx,
        'cy': cy,
        'r': radius,
        'colour': circleColours[randomIntFromInterval(0, 3)]
      };
      circles.push(circle);
      return {
        v: void 0
      };
    }

    guard -= 1;
  };

  while (guard > 0) {
    var _ret = _loop();

    if (_typeof(_ret) === "object") return _ret.v;
  }

  console.log("Guard reached");
}

function randomIntFromInterval(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

function overlapWith(cx1, cy1, r1, cx2, cy2, r2) {
  var d = Math.hypot(cx1 - cx2, cy1 - cy2);
  return d < r1 + r2;
}